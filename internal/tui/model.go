package tui

import (
	"regexp"
	"time"

	"github.com/Iron-Ham/claudio/internal/config"
	"github.com/Iron-Ham/claudio/internal/conflict"
	"github.com/Iron-Ham/claudio/internal/logging"
	"github.com/Iron-Ham/claudio/internal/orchestrator"
	"github.com/Iron-Ham/claudio/internal/tui/command"
	"github.com/Iron-Ham/claudio/internal/tui/input"
	"github.com/Iron-Ham/claudio/internal/tui/output"
	"github.com/Iron-Ham/claudio/internal/tui/search"
	"github.com/Iron-Ham/claudio/internal/tui/terminal"
	"github.com/Iron-Ham/claudio/internal/tui/view"
)

// modelInstanceProvider adapts the Model to the terminal.ActiveInstanceProvider interface.
type modelInstanceProvider struct {
	model *Model
}

// WorktreePath returns the worktree path of the active instance.
func (p modelInstanceProvider) WorktreePath() string {
	if inst := p.model.activeInstance(); inst != nil {
		return inst.WorktreePath
	}
	return ""
}

// PlanEditorState holds the state for the interactive plan editor
type PlanEditorState struct {
	// active indicates whether the plan editor is currently shown
	active bool

	// inlineMode indicates whether this is an inline plan (from :plan command) vs ultraplan mode
	// When true, the plan editor works with InlinePlanState instead of UltraPlanState
	inlineMode bool

	// selectedTaskIdx is the index of the currently selected task in the task list
	selectedTaskIdx int

	// editingField indicates which field is being edited (empty if not editing)
	// Valid values: 'title', 'description', 'files', 'depends_on', 'priority', 'complexity'
	editingField string

	// editBuffer holds the current edit buffer content when editing a field
	editBuffer string

	// editCursor is the cursor position within the edit buffer (0 = before first char)
	editCursor int

	// scrollOffset is the vertical scroll offset for the task list
	scrollOffset int

	// validation holds the current validation results for the plan
	validation *orchestrator.ValidationResult

	// showValidationPanel controls whether the validation panel is visible
	showValidationPanel bool

	// validationScrollOffset is the scroll offset for the validation panel
	validationScrollOffset int

	// tasksInCycle contains task IDs that are part of a dependency cycle (for highlighting)
	tasksInCycle map[string]bool

	// pendingConfirmDelete tracks the task ID awaiting deletion confirmation for started instances
	pendingConfirmDelete string
}

// InlinePlanState holds state for inline plan mode (from :plan command).
// Unlike UltraPlanState which uses the orchestrator.Coordinator for ultraplan workflows,
// InlinePlanState manages a simpler planning flow directly within the TUI.
type InlinePlanState struct {
	// Plan holds the current plan being edited
	Plan *orchestrator.PlanSpec

	// Objective is the user-provided goal for this plan
	Objective string

	// GroupID is the instance group ID created for this plan's tasks
	GroupID string

	// TaskToInstance maps task IDs to instance IDs for tasks that have been materialized
	TaskToInstance map[string]string

	// AwaitingObjective indicates we're waiting for user to input the plan objective
	AwaitingObjective bool

	// IsUltraPlan indicates this is an ultraplan objective prompt (vs regular plan)
	// When true, submitting the objective should create an UltraPlan coordinator
	IsUltraPlan bool

	// UltraPlanConfig holds the config for ultraplan mode (when IsUltraPlan is true)
	UltraPlanConfig *orchestrator.UltraPlanConfig

	// AwaitingPlanCreation indicates we're waiting for the planning instance to generate a plan
	AwaitingPlanCreation bool

	// PlanningInstanceID is the instance ID of the Claude instance creating the plan (if any)
	PlanningInstanceID string

	// MultiPass indicates this plan uses competitive multi-pass planning (3 planners + 1 assessor)
	// When true, PlanningInstanceIDs contains multiple planner instance IDs
	MultiPass bool

	// PlanningInstanceIDs holds the instance IDs for multi-pass planners (one per strategy)
	// Only used when MultiPass is true
	PlanningInstanceIDs []string

	// CandidatePlans holds the plans generated by each multi-pass planner
	// Indexed by planner strategy order
	CandidatePlans []*orchestrator.PlanSpec

	// ProcessedPlanners tracks which planners have completed (by index)
	ProcessedPlanners map[int]bool

	// PlanManagerInstanceID is the instance ID of the plan assessor/manager
	// Only set after all planners complete and the manager is started
	PlanManagerInstanceID string

	// AwaitingPlanManager indicates we're waiting for the plan manager to complete
	AwaitingPlanManager bool
}

// Model holds the TUI application state
type Model struct {
	// Core components
	orchestrator   *orchestrator.Orchestrator
	session        *orchestrator.Session
	logger         *logging.Logger
	startTime      time.Time        // Time when the TUI session started
	commandHandler *command.Handler // Handler for vim-style commands

	// Input routing
	inputRouter *input.Router

	// Terminal pane manager (owns dimensions and layout calculations)
	terminalManager *terminal.Manager

	// Ultra-plan mode (nil if not in ultra-plan mode)
	ultraPlan *UltraPlanState

	// Triple-shot mode (nil if not in triple-shot mode)
	tripleShot *TripleShotState

	// Plan editor mode (nil if not in plan editor mode)
	planEditor *PlanEditorState

	// Inline plan mode (nil if not in inline plan mode)
	// Used for simpler :plan command workflow, separate from ultraPlan
	inlinePlan *InlinePlanState

	// UI state
	activeTab       int
	ready           bool
	quitting        bool
	showHelp        bool
	helpScroll      int  // Scroll offset for help panel
	showConflicts   bool // When true, show detailed conflict view
	addingTask      bool
	taskInput       string
	taskInputCursor int // Cursor position within taskInput (0 = before first char)

	// Dependent task state (for :chain command - adding a task that depends on another)
	addingDependentTask   bool   // When true, taskInput will create a dependent task
	dependentOnInstanceID string // The instance ID that the new task will depend on

	// Triple-shot task state (for :tripleshot command)
	startingTripleShot bool // When true, taskInput will start a triple-shot session

	errorMessage   string
	infoMessage    string    // Non-error status message
	messageSetAt   time.Time // When the current message was set (for auto-dismiss)
	lastMessageKey string    // Used to detect message changes (concatenation of both messages)
	inputMode      bool      // When true, all keys are forwarded to the active instance's tmux session

	// Command mode state (vim-style ex commands with ':' prefix)
	commandMode   bool   // When true, we're typing a command after ':'
	commandBuffer string // The command being typed (without the ':' prefix)

	// Template dropdown state
	showTemplates    bool   // Whether the template dropdown is visible
	templateFilter   string // Current filter text (after the "/")
	templateSelected int    // Currently highlighted template index
	templateSuffix   string // Suffix to append on submission (from selected template)

	// Branch selection state (for selecting base branch when adding task)
	showBranchSelector   bool     // Whether the branch selector is visible
	branchList           []string // Cached list of branch names (unfiltered)
	branchFiltered       []string // Filtered list of branch names based on search
	branchSelected       int      // Currently highlighted branch index in filtered list
	branchScrollOffset   int      // Scroll offset for branch list viewport
	branchSearchInput    string   // Current search/filter text
	selectedBaseBranch   string   // The selected base branch for the new instance
	branchSelectorHeight int      // Visible height for branch list (calculated from terminal)

	// File conflict tracking
	conflicts []conflict.FileConflict

	// Output management (handles per-instance output buffers, scrolling, and auto-scroll)
	outputManager *output.Manager

	// Diff preview state
	showDiff    bool   // Whether the diff panel is visible
	diffContent string // Cached diff content for the active instance
	diffScroll  int    // Scroll offset for navigating the diff

	// Sidebar pagination
	sidebarScrollOffset int // Index of the first visible instance in sidebar

	// Grouped sidebar view state
	groupViewState *view.GroupViewState // State for group collapse/selection (nil until grouped mode is used)
	sidebarMode    view.SidebarMode     // Current sidebar display mode (flat or grouped)

	// Resource metrics display
	showStats bool // When true, show the stats panel

	// Search state
	searchMode   bool           // Whether search mode is active (typing pattern)
	searchInput  string         // Current search input being typed (live updated)
	searchEngine *search.Engine // Search engine for output buffer searching

	// Filter state
	filterMode       bool            // Whether filter mode is active
	filterCategories map[string]bool // Which categories are enabled
	filterCustom     string          // Custom filter pattern
	filterRegex      *regexp.Regexp  // Compiled custom filter regex
	outputScroll     int             // Scroll position in output (for search navigation)

}

// IsUltraPlanMode returns true if the model is in ultra-plan mode
func (m Model) IsUltraPlanMode() bool {
	return m.ultraPlan != nil
}

// IsTripleShotMode returns true if there are any active tripleshot sessions.
func (m Model) IsTripleShotMode() bool {
	return m.tripleShot != nil && m.tripleShot.HasActiveCoordinators()
}

// IsInlinePlanMode returns true if the model is in inline plan mode
func (m Model) IsInlinePlanMode() bool {
	return m.inlinePlan != nil
}

// IsPlanEditorActive returns true if the plan editor is currently active and visible
func (m Model) IsPlanEditorActive() bool {
	return m.planEditor != nil && m.planEditor.active
}

// IsPlanEditorInlineMode returns true if the plan editor is in inline mode (from :plan command)
func (m Model) IsPlanEditorInlineMode() bool {
	return m.planEditor != nil && m.planEditor.inlineMode
}

// GroupViewState returns the current group view state for the sidebar.
// Implements view.SidebarState interface.
func (m Model) GroupViewState() *view.GroupViewState {
	return m.groupViewState
}

// SidebarMode returns the current sidebar display mode.
// Implements view.SidebarState interface.
func (m Model) SidebarMode() view.SidebarMode {
	return m.sidebarMode
}

// UltraPlanState returns the ultraplan state if in ultraplan mode.
// Implements view.SidebarState interface.
func (m Model) UltraPlanState() *view.UltraPlanState {
	return m.ultraPlan
}

// Orchestrator returns the orchestrator for instance lookups.
// Implements view.SidebarState interface.
func (m Model) Orchestrator() *orchestrator.Orchestrator {
	return m.orchestrator
}

// IsInstanceSelected returns true if the given instance ID is currently selected.
// Implements view.SidebarState interface.
func (m Model) IsInstanceSelected(instanceID string) bool {
	if instanceID == "" {
		return false
	}
	if m.activeTab >= 0 && m.activeTab < len(m.session.Instances) {
		return m.session.Instances[m.activeTab].ID == instanceID
	}
	return false
}

// autoEnableGroupedMode switches to grouped sidebar mode when groups exist.
// Call this after creating a new group to automatically show the grouped view.
func (m *Model) autoEnableGroupedMode() {
	if m.session != nil && m.session.HasGroups() && m.sidebarMode == view.SidebarModeFlat {
		m.sidebarMode = view.SidebarModeGrouped
		if m.groupViewState == nil {
			m.groupViewState = view.NewGroupViewState()
		}
	}
}

// enterPlanEditor initializes the plan editor state when entering edit mode
func (m *Model) enterPlanEditor() {
	m.planEditor = &PlanEditorState{
		active:              true,
		inlineMode:          false, // Default to ultraplan mode
		selectedTaskIdx:     0,
		editingField:        "",
		editBuffer:          "",
		editCursor:          0,
		scrollOffset:        0,
		showValidationPanel: true, // Show validation by default
		tasksInCycle:        make(map[string]bool),
	}
	// Run initial validation
	m.updatePlanValidation()
}

// enterInlinePlanEditor initializes the plan editor for inline plan mode
func (m *Model) enterInlinePlanEditor() {
	m.planEditor = &PlanEditorState{
		active:              true,
		inlineMode:          true,
		selectedTaskIdx:     0,
		editingField:        "",
		editBuffer:          "",
		editCursor:          0,
		scrollOffset:        0,
		showValidationPanel: true,
		tasksInCycle:        make(map[string]bool),
	}
	// Run initial validation for inline plan
	m.updateInlinePlanValidation()
}

// updateInlinePlanValidation runs validation on the inline plan and updates the editor state
func (m *Model) updateInlinePlanValidation() {
	if m.planEditor == nil || m.inlinePlan == nil || m.inlinePlan.Plan == nil {
		return
	}

	// Run validation
	m.planEditor.validation = orchestrator.ValidatePlanForEditor(m.inlinePlan.Plan)

	// Update tasks in cycle map for highlighting
	m.planEditor.tasksInCycle = make(map[string]bool)
	cycleTasks := orchestrator.GetTasksInCycle(m.inlinePlan.Plan)
	for _, taskID := range cycleTasks {
		m.planEditor.tasksInCycle[taskID] = true
	}
}

// updatePlanValidation runs validation on the current plan and updates the editor state.
// This supports both inline plan mode and ultra-plan mode.
func (m *Model) updatePlanValidation() {
	if m.planEditor == nil {
		return
	}

	// Handle inline plan mode
	if m.planEditor.inlineMode {
		m.updateInlinePlanValidation()
		return
	}

	// Ultra-plan mode
	if m.ultraPlan == nil || m.ultraPlan.Coordinator == nil {
		return
	}

	session := m.ultraPlan.Coordinator.Session()
	if session == nil || session.Plan == nil {
		return
	}

	// Run validation
	m.planEditor.validation = orchestrator.ValidatePlanForEditor(session.Plan)

	// Update tasks in cycle map for highlighting
	m.planEditor.tasksInCycle = make(map[string]bool)
	cycleTasks := orchestrator.GetTasksInCycle(session.Plan)
	for _, taskID := range cycleTasks {
		m.planEditor.tasksInCycle[taskID] = true
	}
}

// isTaskInCycle returns true if the given task is part of a dependency cycle
func (m *Model) isTaskInCycle(taskID string) bool {
	if m.planEditor == nil || m.planEditor.tasksInCycle == nil {
		return false
	}
	return m.planEditor.tasksInCycle[taskID]
}

// canConfirmPlan returns true if the plan can be confirmed (no validation errors)
func (m *Model) canConfirmPlan() bool {
	if m.planEditor == nil || m.planEditor.validation == nil {
		return false
	}
	return !m.planEditor.validation.HasErrors()
}

// getValidationMessagesForSelectedTask returns validation messages for the currently selected task.
// This supports both inline plan mode and ultra-plan mode.
func (m *Model) getValidationMessagesForSelectedTask() []orchestrator.ValidationMessage {
	if m.planEditor == nil || m.planEditor.validation == nil {
		return nil
	}

	// Get the plan using the unified getter
	plan := m.getPlanForEditor()
	if plan == nil || m.planEditor.selectedTaskIdx >= len(plan.Tasks) {
		return nil
	}

	taskID := plan.Tasks[m.planEditor.selectedTaskIdx].ID
	return m.planEditor.validation.GetMessagesForTask(taskID)
}

// exitPlanEditor cleans up the plan editor state when exiting edit mode
func (m *Model) exitPlanEditor() {
	m.planEditor = nil
}

// NewModel creates a new TUI model
func NewModel(orch *orchestrator.Orchestrator, session *orchestrator.Session, logger *logging.Logger) Model {
	// Create a TUI-specific logger with phase context
	var tuiLogger *logging.Logger
	if logger != nil {
		tuiLogger = logger.WithPhase("tui")
	}

	// Get invocation directory from orchestrator
	invocationDir := ""
	if orch != nil {
		invocationDir = orch.BaseDir()
	}

	// Create terminal manager with configuration
	termMgr := terminal.NewManagerWithConfig(terminal.ManagerConfig{
		InvocationDir: invocationDir,
		Logger:        tuiLogger,
	})

	return Model{
		orchestrator:    orch,
		session:         session,
		logger:          tuiLogger,
		startTime:       time.Now(),
		commandHandler:  command.New(),
		inputRouter:     input.NewRouter(),
		outputManager:   output.NewManager(),
		searchEngine:    search.NewEngine(),
		terminalManager: termMgr,
		filterCategories: map[string]bool{
			"errors":   true,
			"warnings": true,
			"tools":    true,
			"thinking": true,
			"progress": true,
		},
	}
}

// InputRouter returns the input router for this model.
func (m Model) InputRouter() *input.Router {
	return m.inputRouter
}

// syncRouterState synchronizes the InputRouter state with the Model's mode flags.
// This ensures the router reflects the current mode based on the existing boolean flags.
func (m *Model) syncRouterState() {
	if m.inputRouter == nil {
		return
	}

	// Sync mode based on priority order (matching handleKeypress)
	switch {
	case m.searchMode:
		m.inputRouter.SetMode(input.ModeSearch)
	case m.filterMode:
		m.inputRouter.SetMode(input.ModeFilter)
	case m.inputMode:
		m.inputRouter.SetMode(input.ModeInput)
	case m.terminalManager.IsFocused():
		m.inputRouter.SetMode(input.ModeTerminal)
	case m.addingTask:
		m.inputRouter.SetMode(input.ModeTaskInput)
	case m.commandMode:
		m.inputRouter.SetMode(input.ModeCommand)
	default:
		m.inputRouter.SetMode(input.ModeNormal)
	}

	// Sync submode states
	m.inputRouter.SetUltraPlanActive(m.ultraPlan != nil)
	m.inputRouter.SetPlanEditorActive(m.IsPlanEditorActive())
	m.inputRouter.SetTemplateDropdown(m.showTemplates)

	// Sync group decision and retrigger modes from ultra-plan state
	if m.ultraPlan != nil && m.ultraPlan.Coordinator != nil {
		session := m.ultraPlan.Coordinator.Session()
		if session != nil && session.GroupDecision != nil {
			m.inputRouter.SetGroupDecisionMode(session.GroupDecision.AwaitingDecision)
		} else {
			m.inputRouter.SetGroupDecisionMode(false)
		}
		m.inputRouter.SetRetriggerMode(m.ultraPlan.RetriggerMode)
	} else {
		m.inputRouter.SetGroupDecisionMode(false)
		m.inputRouter.SetRetriggerMode(false)
	}

	// Sync command buffer
	m.inputRouter.Buffer = m.commandBuffer
}

// activeInstance returns the currently focused instance
func (m Model) activeInstance() *orchestrator.Instance {
	if m.session == nil || len(m.session.Instances) == 0 {
		return nil
	}

	if m.activeTab >= len(m.session.Instances) {
		return nil
	}

	return m.session.Instances[m.activeTab]
}

// switchToInstance switches focus to a new instance index, pausing the old
// instance's capture and resuming the new one. This reduces overhead by not
// capturing output for background instances.
//
// In grouped sidebar mode, this also handles auto-expand/collapse of groups:
// - When navigating to an instance in a collapsed group, the group auto-expands
// - When navigating away from an auto-expanded group, the group auto-collapses
func (m *Model) switchToInstance(newTab int) {
	if m.session == nil || len(m.session.Instances) == 0 {
		return
	}

	// Clamp newTab to valid range
	if newTab < 0 || newTab >= len(m.session.Instances) {
		return
	}

	oldTab := m.activeTab
	if oldTab == newTab {
		return // No change needed
	}

	// Handle group auto-expand/collapse in grouped mode
	if m.groupViewState != nil && m.sidebarMode == view.SidebarModeGrouped && m.session.HasGroups() {
		m.handleGroupAutoExpandCollapse(oldTab, newTab)
	}

	// Pause the old active instance's capture
	// Note: Pause() currently always returns nil, so error is safely discarded
	if oldTab >= 0 && oldTab < len(m.session.Instances) {
		oldInst := m.session.Instances[oldTab]
		if mgr := m.orchestrator.GetInstanceManager(oldInst.ID); mgr != nil {
			_ = mgr.Pause()
		}
	}

	// Switch to the new tab
	m.activeTab = newTab

	// Resume the new active instance's capture
	// Note: Resume() currently always returns nil, so error is safely discarded
	newInst := m.session.Instances[newTab]
	if mgr := m.orchestrator.GetInstanceManager(newInst.ID); mgr != nil {
		_ = mgr.Resume()
	}
}

// handleGroupAutoExpandCollapse manages automatic group expansion and collapse
// when navigating between instances in grouped sidebar mode.
func (m *Model) handleGroupAutoExpandCollapse(oldTab, newTab int) {
	var oldInstanceID, newInstanceID string

	if oldTab >= 0 && oldTab < len(m.session.Instances) {
		oldInstanceID = m.session.Instances[oldTab].ID
	}
	if newTab >= 0 && newTab < len(m.session.Instances) {
		newInstanceID = m.session.Instances[newTab].ID
	}

	// Find which groups contain each instance
	oldGroupPath := view.FindGroupContainingInstance(m.session, oldInstanceID)
	newGroupPath := view.FindGroupContainingInstance(m.session, newInstanceID)

	// Convert to sets for easier comparison
	oldGroups := make(map[string]bool)
	for _, gid := range oldGroupPath {
		oldGroups[gid] = true
	}
	newGroups := make(map[string]bool)
	for _, gid := range newGroupPath {
		newGroups[gid] = true
	}

	// Auto-collapse groups we're leaving (that were auto-expanded)
	for _, gid := range oldGroupPath {
		if !newGroups[gid] {
			// We're leaving this group - collapse it if it was auto-expanded
			m.groupViewState.AutoCollapse(gid)
		}
	}

	// Auto-expand groups we're entering (that are collapsed)
	for _, gid := range newGroupPath {
		if !oldGroups[gid] && m.groupViewState.IsCollapsed(gid) {
			// We're entering this collapsed group - auto-expand it
			m.groupViewState.AutoExpand(gid)
		}
	}
}

// pauseInstance pauses an instance's capture without switching tabs.
// Used when adding new instances to pause the previously active one.
// Note: Pause() currently always returns nil, so error is safely discarded.
func (m *Model) pauseInstance(instanceID string) {
	if mgr := m.orchestrator.GetInstanceManager(instanceID); mgr != nil {
		_ = mgr.Pause()
	}
}

// resumeActiveInstance resumes the capture loop for the currently active instance.
// This should be called after any direct modification of activeTab (e.g., after
// instance removal) to ensure the new active instance's output is being captured.
// Without this, removed instances can leave the remaining instance in a paused state.
func (m *Model) resumeActiveInstance() {
	if m.orchestrator == nil {
		return
	}
	if inst := m.activeInstance(); inst != nil {
		if mgr := m.orchestrator.GetInstanceManager(inst.ID); mgr != nil {
			// Note: Resume() currently always returns nil, so error is safely discarded
			_ = mgr.Resume()
		}
	}
}

// instanceCount returns the number of instances
func (m Model) instanceCount() int {
	if m.session == nil {
		return 0
	}
	return len(m.session.Instances)
}

// isGroupedSidebarMode returns true if the sidebar is in grouped mode with groups present.
// This is used to determine whether navigation should follow display order or creation order.
func (m Model) isGroupedSidebarMode() bool {
	return m.sidebarMode == view.SidebarModeGrouped &&
		m.groupViewState != nil &&
		m.session != nil &&
		m.session.HasGroups()
}

// getInstanceDisplayOrder returns instance IDs in the order they appear in the sidebar.
// This accounts for grouped mode where ungrouped instances appear first, followed by
// instances organized by group hierarchy. In flat mode, returns instances in their
// original session.Instances order.
func (m Model) getInstanceDisplayOrder() []string {
	if m.session == nil || len(m.session.Instances) == 0 {
		return nil
	}

	// In flat mode or when there are no groups, use session.Instances order directly
	if !m.isGroupedSidebarMode() {
		ids := make([]string, len(m.session.Instances))
		for i, inst := range m.session.Instances {
			ids[i] = inst.ID
		}
		return ids
	}

	// In grouped mode, get the flattened display order
	// Use the same logic as the sidebar rendering
	var ultraPlanGroupID string
	if m.ultraPlan != nil && m.ultraPlan.Coordinator != nil {
		if upSession := m.ultraPlan.Coordinator.Session(); upSession != nil {
			ultraPlanGroupID = upSession.GroupID
		}
	}

	items := view.FlattenGroupsForDisplayWithUltraPlan(m.session, m.groupViewState, ultraPlanGroupID, m.ultraPlan)
	ids := make([]string, 0, len(m.session.Instances))
	for _, item := range items {
		if gi, ok := item.(view.GroupedInstance); ok {
			ids = append(ids, gi.Instance.ID)
		}
	}
	return ids
}

// findInstanceIndexByID returns the index of an instance in session.Instances by ID.
// Returns -1 if not found.
func (m Model) findInstanceIndexByID(id string) int {
	if m.session == nil {
		return -1
	}
	for i, inst := range m.session.Instances {
		if inst.ID == id {
			return i
		}
	}
	return -1
}

// ensureActiveVisible adjusts sidebarScrollOffset to keep activeTab visible
func (m *Model) ensureActiveVisible() {
	// Calculate visible slots (same calculation as in renderSidebar)
	// Reserve: 1 for title, 1 for blank line, 1 for add hint, 2 for scroll indicators, plus border padding
	reservedLines := 6
	dims := m.terminalManager.GetPaneDimensions(m.calculateExtraFooterLines())
	availableSlots := dims.MainAreaHeight - reservedLines
	if availableSlots < 3 {
		availableSlots = 3
	}

	// Adjust scroll offset to keep active instance visible
	if m.activeTab < m.sidebarScrollOffset {
		// Active is above visible area, scroll up
		m.sidebarScrollOffset = m.activeTab
	} else if m.activeTab >= m.sidebarScrollOffset+availableSlots {
		// Active is below visible area, scroll down
		m.sidebarScrollOffset = m.activeTab - availableSlots + 1
	}

	// Ensure scroll offset is within valid bounds
	if m.sidebarScrollOffset < 0 {
		m.sidebarScrollOffset = 0
	}
	maxOffset := m.instanceCount() - availableSlots
	if maxOffset < 0 {
		maxOffset = 0
	}
	if m.sidebarScrollOffset > maxOffset {
		m.sidebarScrollOffset = maxOffset
	}
}

// Output scroll helper methods
// These methods delegate to the OutputManager for output buffer management.

// getOutputMaxLines returns the maximum number of lines visible in the output area
func (m Model) getOutputMaxLines() int {
	dims := m.terminalManager.GetPaneDimensions(m.calculateExtraFooterLines())

	// Calculate overhead based on the active instance's actual properties
	overhead := m.calculateInstanceOverhead()

	maxLines := dims.MainAreaHeight - overhead
	if maxLines < 5 {
		maxLines = 5
	}
	return maxLines
}

// calculateInstanceOverhead calculates the number of lines used by the instance view
// for elements other than the output area (header, task, dependencies, metrics, etc.)
func (m Model) calculateInstanceOverhead() int {
	inst := m.activeInstance()
	if inst == nil {
		// Default overhead when no instance is selected
		return 6
	}

	// Check if this instance is running
	mgr := m.orchestrator.GetInstanceManager(inst.ID)
	isRunning := mgr != nil && mgr.Running()

	// Check config for metrics display
	cfg := config.Get()
	showMetrics := cfg.Resources.ShowMetricsInSidebar
	hasMetrics := inst.Metrics != nil

	// Build overhead params
	params := view.OverheadParams{
		Task:            inst.Task,
		HasDependencies: len(inst.DependsOn) > 0,
		HasDependents:   len(inst.Dependents) > 0,
		ShowMetrics:     showMetrics,
		HasMetrics:      hasMetrics,
		IsRunning:       isRunning,
		HasSearchActive: m.searchMode || m.searchInput != "",
		// Always assume scroll indicator will be shown to avoid overflow
		// This is a conservative estimate that prevents clipping
		HasScrollIndicator: true,
	}

	instanceView := view.NewInstanceView(0, 0) // Dimensions not needed for overhead calculation
	return instanceView.CalculateOverheadLines(params)
}

// isOutputAutoScroll returns whether auto-scroll is enabled for an instance (defaults to true)
func (m Model) isOutputAutoScroll(instanceID string) bool {
	return m.outputManager.IsAutoScroll(instanceID)
}

// scrollOutputUp scrolls the output up by n lines and disables auto-scroll
func (m *Model) scrollOutputUp(instanceID string, n int) {
	m.outputManager.SetFilterFunc(m.filterOutput)
	m.outputManager.Scroll(instanceID, -n, m.getOutputMaxLines())
}

// scrollOutputDown scrolls the output down by n lines
func (m *Model) scrollOutputDown(instanceID string, n int) {
	m.outputManager.SetFilterFunc(m.filterOutput)
	m.outputManager.Scroll(instanceID, n, m.getOutputMaxLines())
}

// scrollOutputToTop scrolls to the top of the output and disables auto-scroll
func (m *Model) scrollOutputToTop(instanceID string) {
	m.outputManager.ScrollToTop(instanceID)
}

// scrollOutputToBottom scrolls to the bottom and re-enables auto-scroll
func (m *Model) scrollOutputToBottom(instanceID string) {
	m.outputManager.SetFilterFunc(m.filterOutput)
	m.outputManager.ScrollToBottom(instanceID, m.getOutputMaxLines())
}

// updateOutputScroll updates scroll position based on new output (if auto-scroll is enabled)
func (m *Model) updateOutputScroll(instanceID string) {
	m.outputManager.SetFilterFunc(m.filterOutput)
	m.outputManager.UpdateScroll(instanceID, m.getOutputMaxLines())
}

// hasNewOutput returns true if there's new output since last update
func (m Model) hasNewOutput(instanceID string) bool {
	return m.outputManager.HasNewOutput(instanceID)
}

// Task input cursor helper methods

// taskInputInsert inserts text at the current cursor position
func (m *Model) taskInputInsert(text string) {
	runes := []rune(m.taskInput)
	m.taskInput = string(runes[:m.taskInputCursor]) + text + string(runes[m.taskInputCursor:])
	m.taskInputCursor += len([]rune(text))
}

// taskInputDeleteBack deletes n runes before the cursor
func (m *Model) taskInputDeleteBack(n int) {
	if m.taskInputCursor == 0 {
		return
	}
	runes := []rune(m.taskInput)
	deleteCount := n
	if deleteCount > m.taskInputCursor {
		deleteCount = m.taskInputCursor
	}
	m.taskInput = string(runes[:m.taskInputCursor-deleteCount]) + string(runes[m.taskInputCursor:])
	m.taskInputCursor -= deleteCount
}

// taskInputDeleteForward deletes n runes after the cursor
func (m *Model) taskInputDeleteForward(n int) {
	runes := []rune(m.taskInput)
	if m.taskInputCursor >= len(runes) {
		return
	}
	deleteCount := n
	if m.taskInputCursor+deleteCount > len(runes) {
		deleteCount = len(runes) - m.taskInputCursor
	}
	m.taskInput = string(runes[:m.taskInputCursor]) + string(runes[m.taskInputCursor+deleteCount:])
}

// taskInputMoveCursor moves cursor by n runes (negative = left, positive = right)
func (m *Model) taskInputMoveCursor(n int) {
	runes := []rune(m.taskInput)
	newPos := m.taskInputCursor + n
	if newPos < 0 {
		newPos = 0
	}
	if newPos > len(runes) {
		newPos = len(runes)
	}
	m.taskInputCursor = newPos
}

// taskInputFindPrevWordBoundary finds the position of the previous word boundary
func (m *Model) taskInputFindPrevWordBoundary() int {
	if m.taskInputCursor == 0 {
		return 0
	}
	runes := []rune(m.taskInput)
	pos := m.taskInputCursor - 1

	// Skip any whitespace/punctuation immediately before cursor
	for pos > 0 && !isWordChar(runes[pos]) {
		pos--
	}
	// Move back through the word
	for pos > 0 && isWordChar(runes[pos-1]) {
		pos--
	}
	return pos
}

// taskInputFindNextWordBoundary finds the position of the next word boundary
func (m *Model) taskInputFindNextWordBoundary() int {
	runes := []rune(m.taskInput)
	if m.taskInputCursor >= len(runes) {
		return len(runes)
	}
	pos := m.taskInputCursor

	// Skip current word
	for pos < len(runes) && isWordChar(runes[pos]) {
		pos++
	}
	// Skip whitespace/punctuation to reach next word
	for pos < len(runes) && !isWordChar(runes[pos]) {
		pos++
	}
	return pos
}

// taskInputFindLineStart finds the start of the current line
func (m *Model) taskInputFindLineStart() int {
	runes := []rune(m.taskInput)
	pos := m.taskInputCursor
	for pos > 0 && runes[pos-1] != '\n' {
		pos--
	}
	return pos
}

// taskInputFindLineEnd finds the end of the current line
func (m *Model) taskInputFindLineEnd() int {
	runes := []rune(m.taskInput)
	pos := m.taskInputCursor
	for pos < len(runes) && runes[pos] != '\n' {
		pos++
	}
	return pos
}

// isWordChar returns true if the rune is considered part of a word
func isWordChar(r rune) bool {
	return (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_'
}

// -----------------------------------------------------------------------------
// Terminal pane helper methods
// -----------------------------------------------------------------------------

// IsTerminalMode returns true if the terminal pane has input focus.
func (m Model) IsTerminalMode() bool {
	return m.terminalManager.IsFocused()
}

// IsTerminalVisible returns true if the terminal pane is visible.
func (m Model) IsTerminalVisible() bool {
	return m.terminalManager.IsVisible()
}

// TerminalPaneHeight returns the current terminal pane height (0 if hidden).
func (m Model) TerminalPaneHeight() int {
	dims := m.terminalManager.GetPaneDimensions(0)
	return dims.TerminalPaneHeight
}

// getTerminalDir returns the directory path for the terminal based on current mode.
func (m Model) getTerminalDir() string {
	return m.terminalManager.GetDir(modelInstanceProvider{model: &m})
}

// toggleTerminalVisibility toggles the terminal pane on or off.
// If turning on and process doesn't exist, it will be created lazily.
func (m *Model) toggleTerminalVisibility(sessionID string) {
	errMsg, warnMsg := m.terminalManager.Toggle(sessionID)
	if errMsg != "" {
		m.errorMessage = errMsg
	} else if warnMsg != "" {
		m.infoMessage = warnMsg
	}
}

// enterTerminalMode enters terminal input mode (keys go to terminal).
func (m *Model) enterTerminalMode() {
	m.terminalManager.EnterMode()
}

// exitTerminalMode exits terminal input mode.
func (m *Model) exitTerminalMode() {
	m.terminalManager.ExitMode()
}

// switchTerminalDir toggles between worktree and invocation directory modes.
func (m *Model) switchTerminalDir() {
	infoMsg, errMsg := m.terminalManager.SwitchDir(modelInstanceProvider{model: m})
	if errMsg != "" {
		m.errorMessage = errMsg
	} else if infoMsg != "" {
		m.infoMessage = infoMsg
	}
}

// updateTerminalOutput captures current terminal output.
func (m *Model) updateTerminalOutput() {
	m.terminalManager.UpdateOutput()
}

// resizeTerminal updates the terminal dimensions.
func (m *Model) resizeTerminal() {
	m.terminalManager.Resize()
}

// cleanupTerminal stops the terminal process (called on quit).
func (m *Model) cleanupTerminal() {
	m.terminalManager.Cleanup()
}

// updateTerminalOnInstanceChange updates terminal directory if in worktree mode.
// Called when the active instance changes.
func (m *Model) updateTerminalOnInstanceChange() {
	if errMsg := m.terminalManager.UpdateOnInstanceChange(modelInstanceProvider{model: m}); errMsg != "" {
		m.errorMessage = errMsg
	}
}

// -----------------------------------------------------------------------------
// DashboardState interface implementation
// These methods implement the view.DashboardState interface, allowing the Model
// to be passed to view components for rendering.
// -----------------------------------------------------------------------------

// Session returns the current orchestrator session.
func (m Model) Session() *orchestrator.Session {
	return m.session
}

// ActiveTab returns the index of the currently selected instance.
func (m Model) ActiveTab() int {
	return m.activeTab
}

// SidebarScrollOffset returns the scroll offset for the sidebar.
func (m Model) SidebarScrollOffset() int {
	return m.sidebarScrollOffset
}

// Conflicts returns the current file conflicts.
func (m Model) Conflicts() []conflict.FileConflict {
	return m.conflicts
}

// TerminalWidth returns the terminal width.
func (m Model) TerminalWidth() int {
	return m.terminalManager.Width()
}

// TerminalHeight returns the terminal height.
func (m Model) TerminalHeight() int {
	return m.terminalManager.Height()
}

// IsAddingTask returns whether the user is currently adding a new task
func (m Model) IsAddingTask() bool {
	return m.addingTask
}

// IntelligentNamingEnabled returns whether intelligent naming is enabled in config
func (m Model) IntelligentNamingEnabled() bool {
	cfg := config.Get()
	return cfg.Experimental.IntelligentNaming
}

// -----------------------------------------------------------------------------
// command.Dependencies interface implementation
// These methods implement the command.Dependencies interface, allowing the Model
// to be passed to the CommandHandler for command execution.
// -----------------------------------------------------------------------------

// GetOrchestrator returns the orchestrator instance.
func (m Model) GetOrchestrator() *orchestrator.Orchestrator {
	return m.orchestrator
}

// GetSession returns the current session.
func (m Model) GetSession() *orchestrator.Session {
	return m.session
}

// ActiveInstance returns the currently focused instance.
func (m Model) ActiveInstance() *orchestrator.Instance {
	return m.activeInstance()
}

// InstanceCount returns the number of instances.
func (m Model) InstanceCount() int {
	return m.instanceCount()
}

// GetConflicts returns the number of file conflicts.
func (m Model) GetConflicts() int {
	return len(m.conflicts)
}

// IsDiffVisible returns true if the diff panel is visible.
func (m Model) IsDiffVisible() bool {
	return m.showDiff
}

// GetDiffContent returns the current diff content.
func (m Model) GetDiffContent() string {
	return m.diffContent
}

// GetUltraPlanCoordinator returns the ultraplan coordinator if in ultraplan mode.
func (m Model) GetUltraPlanCoordinator() *orchestrator.Coordinator {
	if m.ultraPlan == nil {
		return nil
	}
	return m.ultraPlan.Coordinator
}

// GetTripleShotCoordinators returns all active tripleshot coordinators.
func (m Model) GetTripleShotCoordinators() []*orchestrator.TripleShotCoordinator {
	if m.tripleShot == nil {
		return nil
	}
	return m.tripleShot.GetAllCoordinators()
}

// GetLogger returns the logger instance.
func (m Model) GetLogger() *logging.Logger {
	return m.logger
}

// GetStartTime returns the TUI session start time.
func (m Model) GetStartTime() time.Time {
	return m.startTime
}

// IsInstanceTripleShotJudge checks if an instance is a judge in any active triple-shot session.
func (m Model) IsInstanceTripleShotJudge(instanceID string) bool {
	if m.tripleShot == nil {
		return false
	}
	// Check all coordinators in the map
	for _, coord := range m.tripleShot.Coordinators {
		session := coord.Session()
		if session != nil && session.JudgeID == instanceID {
			return true
		}
	}
	return false
}

// -----------------------------------------------------------------------------
// search.Context interface implementation
// These methods implement the search.Context interface for the search Handler.
// -----------------------------------------------------------------------------

// modelSearchContext adapts the Model to implement search.Context.
// This allows the search Handler to interact with the Model without circular imports.
type modelSearchContext struct {
	model *Model
}

// GetSearchInput returns the current search input string.
func (c *modelSearchContext) GetSearchInput() string {
	return c.model.searchInput
}

// SetSearchInput sets the search input string.
func (c *modelSearchContext) SetSearchInput(input string) {
	c.model.searchInput = input
}

// GetSearchEngine returns the search engine.
func (c *modelSearchContext) GetSearchEngine() *search.Engine {
	return c.model.searchEngine
}

// GetOutputForActiveInstance returns output for the active instance.
func (c *modelSearchContext) GetOutputForActiveInstance() string {
	if inst := c.model.activeInstance(); inst != nil {
		return c.model.outputManager.GetOutput(inst.ID)
	}
	return ""
}

// GetViewportHeight returns the output viewport height.
func (c *modelSearchContext) GetViewportHeight() int {
	return c.model.terminalManager.Height() - 12
}

// GetOutputScroll returns the current output scroll position.
func (c *modelSearchContext) GetOutputScroll() int {
	return c.model.outputScroll
}

// SetOutputScroll sets the output scroll position.
func (c *modelSearchContext) SetOutputScroll(scroll int) {
	c.model.outputScroll = scroll
}

// newSearchContext creates a search context adapter for the model.
func (m *Model) newSearchContext() *modelSearchContext {
	return &modelSearchContext{model: m}
}

// SearchHandler returns a new search handler for this model.
func (m *Model) SearchHandler() *search.Handler {
	return search.NewHandler(m.newSearchContext())
}

// -----------------------------------------------------------------------------
// update.Context interface implementation
// These methods implement the update.Context interface for the update package.
// -----------------------------------------------------------------------------

// modelUpdateContext adapts the Model to implement update.Context.
// This allows the update handlers to interact with the Model without circular imports.
type modelUpdateContext struct {
	model *Model
}

// Session returns the current orchestrator session.
func (c *modelUpdateContext) Session() *orchestrator.Session {
	return c.model.session
}

// Orchestrator returns the orchestrator instance.
func (c *modelUpdateContext) Orchestrator() *orchestrator.Orchestrator {
	return c.model.orchestrator
}

// OutputManager returns the output manager for instance output handling.
func (c *modelUpdateContext) OutputManager() *output.Manager {
	return c.model.outputManager
}

// Logger returns the logger instance (may be nil).
func (c *modelUpdateContext) Logger() *logging.Logger {
	return c.model.logger
}

// InstanceCount returns the number of instances.
func (c *modelUpdateContext) InstanceCount() int {
	return c.model.instanceCount()
}

// ActiveInstance returns the currently active instance (may be nil).
func (c *modelUpdateContext) ActiveInstance() *orchestrator.Instance {
	return c.model.activeInstance()
}

// SetErrorMessage sets an error message to display.
func (c *modelUpdateContext) SetErrorMessage(msg string) {
	c.model.errorMessage = msg
}

// SetInfoMessage sets an info message to display.
func (c *modelUpdateContext) SetInfoMessage(msg string) {
	c.model.infoMessage = msg
}

// ClearInfoMessage clears the info message.
func (c *modelUpdateContext) ClearInfoMessage() {
	c.model.infoMessage = ""
}

// SetActiveTab sets the active tab index.
func (c *modelUpdateContext) SetActiveTab(idx int) {
	c.model.activeTab = idx
}

// PauseInstance pauses the output capture for an instance.
func (c *modelUpdateContext) PauseInstance(instanceID string) {
	c.model.pauseInstance(instanceID)
}

// EnsureActiveVisible ensures the active tab is visible in the sidebar.
func (c *modelUpdateContext) EnsureActiveVisible() {
	c.model.ensureActiveVisible()
}

// newUpdateContext creates an update context adapter for the model.
func (m *Model) newUpdateContext() *modelUpdateContext {
	return &modelUpdateContext{model: m}
}
