# Task: Write tests for SynthesisOrchestrator

## Part of Ultra-Plan: Extract the 3,805-line monolithic Coordinator into four phase-specific orchestrators (PlanningOrchestrator, ExecutionOrchestrator, SynthesisOrchestrator, ConsolidationOrchestrator) using the existing PhaseExecutor interface pattern. Each orchestrator owns one phase of ultra-plan execution with its own state management, monitoring, and restart capability. The main Coordinator becomes a thin dispatcher (~500 lines) that instantiates orchestrators and delegates phase operations. This enables independent testing of each phase, improves code organization, and eliminates the god-object anti-pattern.

## Your Task

Create internal/orchestrator/phase/synthesis_test.go with table-driven tests covering synthesis execution, completion handling, approval flow, and revision phase. Target 100% coverage on new code.

## Expected Files

You are expected to work with these files:
- internal/orchestrator/phase/synthesis_test.go

## Context from Previous Group

This task builds on work consolidated from Group 5.

**Consolidator Notes**: Successfully consolidated 4 task branches onto Group 4's base. All cherry-picks applied with only CHANGELOG.md requiring manual merge. Lint fixes applied: replaced WriteString(fmt.Sprintf(...)) with fmt.Fprintf(...) in BuildGroupConsolidatorPrompt helper functions, and fixed gofmt spacing in synthesis_test.go. The consolidated branch adds: (1) Task completion and group advancement logic in ExecutionOrchestrator with duplicate detection, retry handling, and synthesis transition, (2) Revision phase implementation in SynthesisOrchestrator with full lifecycle support for spawning targeted fixes, (3) Per-group consolidation methods in ConsolidationOrchestrator for synchronous consolidation between execution groups, (4) Comprehensive table-driven tests for PlanningOrchestrator with 621 lines of new test coverage.

**Important**: The previous group's consolidator flagged these issues:
- The Coordinator needs to implement the extended interfaces: ExecutionCoordinatorInterface (11 new methods), RevisionOrchestratorInterface (AddInstanceToWorktree, RunSynthesis), RevisionSessionInterface (GetRevisionState, SetRevisionState, GetRevisionID, SetRevisionID), GroupConsolidationSessionInterface, GroupConsolidationOrchestratorInterface, and TaskCompletionFileParser
- Consider creating a wrapper around group.Tracker that implements GroupTrackerInterface for the Coordinator to provide to ExecutionOrchestrator
- Several types (TaskWorktreeInfo, ConsolidationTaskWorktreeInfo, GroupTaskInfo, TaskCompletionFile, GroupConsolidationCompletionFile) are duplicated between packages - consider moving to a shared types package
- The slugify() helper function in SynthesisOrchestrator is used for matching instances to tasks by branch name - ensure it's consistent with branch naming during execution
- The setInstanceID method in PlanningOrchestrator is unused but reserved for future multi-pass planning - consider removing if not needed
- extractInstanceID in PlanningOrchestrator contains some dead code paths (type switch cases that are never reached) - consider simplifying

The consolidated code from the previous group has been verified (build/lint/tests passed).

## Guidelines

- Focus only on this specific task
- Do not modify files outside of your assigned scope unless necessary
- Commit your changes before writing the completion file

## Completion Protocol

When your task is complete, you MUST write a completion file to signal the orchestrator:

1. Use Write tool to create `.claudio-task-complete.json` in your worktree root
2. Include this JSON structure:
```json
{
  "task_id": "task-20-tests-synthesis",
  "status": "complete",
  "summary": "Brief description of what you accomplished",
  "files_modified": ["list", "of", "files", "you", "changed"],
  "notes": "Any implementation notes for the consolidation phase",
  "issues": ["Any concerns or blocking issues found"],
  "suggestions": ["Suggestions for integration with other tasks"],
  "dependencies": ["Any new runtime dependencies added"]
}
```

3. Use status "blocked" if you cannot complete (explain in issues), or "failed" if something broke
4. This file signals that your work is done and provides context for consolidation
