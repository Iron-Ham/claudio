# Task: Implement execution loop and task spawning

## Part of Ultra-Plan: Extract the 3,805-line monolithic Coordinator into four phase-specific orchestrators (PlanningOrchestrator, ExecutionOrchestrator, SynthesisOrchestrator, ConsolidationOrchestrator) using the existing PhaseExecutor interface pattern. Each orchestrator owns one phase of ultra-plan execution with its own state management, monitoring, and restart capability. The main Coordinator becomes a thin dispatcher (~500 lines) that instantiates orchestrators and delegates phase operations. This enables independent testing of each phase, improves code organization, and eliminates the god-object anti-pattern.

## Your Task

Extract executionLoop(), startTask(), and buildTaskPrompt() into ExecutionOrchestrator. Include the main loop with context cancellation, completion channel handling, ready task polling, and MaxParallel enforcement. Task spawning includes prompt building, instance creation, group assignment, and goroutine monitoring.

## Expected Files

You are expected to work with these files:
- internal/orchestrator/phase/execution.go

## Context from Previous Group

This task builds on work consolidated from Group 2.

**Consolidator Notes**: Successfully consolidated 3 of 5 tasks. The SynthesisOrchestrator, ConsolidationOrchestrator, and Coordinator phase adapters were cherry-picked and merged cleanly. A minor lint fix was required for an unused WaitGroup field in SynthesisOrchestrator that is reserved for future use. Two tasks (task-2-planning-struct and task-5-execution-struct for PlanningOrchestrator and ExecutionOrchestrator) were not completed in their worktree.

**Important**: The previous group's consolidator flagged these issues:
- PlanningOrchestrator (task-2-planning-struct) was NOT implemented - next group should implement this struct following the same pattern as SynthesisOrchestrator and ConsolidationOrchestrator
- ExecutionOrchestrator (task-5-execution-struct) was NOT implemented - next group should implement this struct following the same pattern as SynthesisOrchestrator and ConsolidationOrchestrator
- The SynthesisOrchestrator.wg field has a nolint directive - when implementing the full Execute method with goroutines, remove the nolint comment and use the WaitGroup properly
- The mirrored types (RevisionIssue, SynthesisCompletionFile) in phase/synthesis.go could be moved to a shared types package to avoid duplication with orchestrator package types
- Consider adding AddInstanceFromBranch to OrchestratorInterface if execution orchestrator needs branch-based instance creation

The consolidated code from the previous group has been verified (build/lint/tests passed).

## Guidelines

- Focus only on this specific task
- Do not modify files outside of your assigned scope unless necessary
- Commit your changes before writing the completion file

## Completion Protocol

When your task is complete, you MUST write a completion file to signal the orchestrator:

1. Use Write tool to create `.claudio-task-complete.json` in your worktree root
2. Include this JSON structure:
```json
{
  "task_id": "task-6-execution-loop",
  "status": "complete",
  "summary": "Brief description of what you accomplished",
  "files_modified": ["list", "of", "files", "you", "changed"],
  "notes": "Any implementation notes for the consolidation phase",
  "issues": ["Any concerns or blocking issues found"],
  "suggestions": ["Suggestions for integration with other tasks"],
  "dependencies": ["Any new runtime dependencies added"]
}
```

3. Use status "blocked" if you cannot complete (explain in issues), or "failed" if something broke
4. This file signals that your work is done and provides context for consolidation
